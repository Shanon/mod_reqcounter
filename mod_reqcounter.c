/* 
**  mod_reqcounter.c -- Apache sample reqcounter module
**  [Autogenerated via ``apxs -n reqcounter -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_reqcounter.c
**
**  Then activate it in Apache's httpd.conf file for instance
**  for the URL /reqcounter in as follows:
**
**    #   httpd.conf
**    LoadModule reqcounter_module modules/mod_reqcounter.so
**    <Location /reqcounter>
**    SetHandler reqcounter
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /reqcounter and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/reqcounter 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_reqcounter.c
*/ 

//#include <stdio.h>
//#include <stdbool.h>
#include "httpd.h"
#include "http_config.h"
#include "http_log.h"
#include "http_main.h"
#include "http_protocol.h"
#include "http_request.h"

#include "ap_config.h"
#include "apr_tables.h"
#include "apr_global_mutex.h"
#include "apr_shm.h"
#include "apr_strings.h"
#include "apr_time.h"

//#define _DEBUG

#ifdef _DEBUG
  #define DEBUGLOG(...) ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, 0, NULL, __VA_ARGS__)
#else
  #define DEBUGLOG(...)
#endif

#define MODULE_NAME "mod_reqcounter"
#define MODULE_VERSION "0.1"

#define SHM_DIR "logs/reqcounter/"
//#define SHM_FILE "logs/reqcounter.shm"
//#define LOCK_FILE "logs/reqcounter.lock"

module AP_MODULE_DECLARE_DATA reqcounter_module;

struct s_server_count {
    char server_hostname[64];
    char mutex_name[256];
    unsigned int count[3600];
    apr_time_t last_apr_time;
    int is_use;
    apr_global_mutex_t *mutex;
    struct s_server_count* next;
};
typedef struct s_server_count server_count_t;

typedef struct {
    server_count_t *head;
    server_count_t base[1];
} server_list_t;

typedef struct ReqCounterConfig {
    signed int flag;
    signed int persent_flag;
    unsigned int range_short;
    unsigned int range_long;
    unsigned int add_buf_num;
    char *shmdir;
//    apr_table_t *server_table;
//    apr_global_mutex_t mutexs[100];
//    apr_table_t *mutex_table;
//    apr_table_t *shm_table;
//    char *lockfile;
//    char *shmfile;
//    apr_global_mutex_t *mutex;
    apr_shm_t *shm;
//    apr_table_t *data;
    server_list_t *server_list;
} reqcounter_config;



static void *reqcounter_create_server_config(apr_pool_t *p, server_rec *s)
{
    DEBUGLOG("call: reqcounter_create_server_config");
    reqcounter_config *config = (reqcounter_config *)apr_palloc(p, sizeof(*config));
    config->flag = 0;
    config->persent_flag = 0;
    config->range_short = 300;
    config->range_long = 10;
    config->add_buf_num = 100;
    
    config->shmdir = ap_server_root_relative( p, SHM_DIR );
    config->shm = NULL;

    
    /*
    config->server_table = (apr_table_t *)apr_table_make(p, 0);
    config->mutex_table = (apr_table_t *)apr_table_make(p, 0);
    config->shm_table = (apr_table_t *)apr_table_make(p, 0);
    config->shmfile = ap_server_root_relative( p, SHM_FILE);
    config->lockfile = ap_server_root_relative(p, LOCK_FILE);
    config->mutex = NULL;
    config->data = (apr_table_t *)apr_table_make(p, 1);
    */
    DEBUGLOG("end : reqcounter_create_server_config");
    return (void *)config;
}


static const char *set_reqcount_flag(cmd_parms *cmd, void *mconfig, int flg)
{
    DEBUGLOG("call: set_reqcount_flag: %d", flg);
    
    reqcounter_config *config = (reqcounter_config *)
        ap_get_module_config(cmd->server->module_config, &reqcounter_module);
    
    config->flag = flg;
    DEBUGLOG("config->flag : %d", config->flag);
    
    DEBUGLOG("end : set_reqcounter_flag");
    return NULL;
}

static const char *set_reqcount_range_short(cmd_parms *cmd,
                                            void *mconfig,
                                            const char *arg )
{
    DEBUGLOG("call: set_reqcount_range_short: %s", arg);
    reqcounter_config *config = (reqcounter_config *)
        ap_get_module_config(cmd->server->module_config, &reqcounter_module);
    
    config->range_short = atoi(arg);
    DEBUGLOG("config->range_short : %d", config->range_short );
    DEBUGLOG("end : set_reqcount_range_short");
    return NULL;
}

static const char *set_reqcount_range_long(cmd_parms *cmd,
                                           void *mconfig,
                                           const char *arg )
{
    DEBUGLOG("call: set_reqcount_range_long: %s", arg);
    reqcounter_config *config = (reqcounter_config *)
        ap_get_module_config(cmd->server->module_config, &reqcounter_module);
    
    config->range_long = atoi(arg);
    DEBUGLOG("config->range_long : %d", config->range_long );
    DEBUGLOG("end : set_reqcount_range_long");
    return NULL;
}

static const char *set_reqcount_addbufnum(cmd_parms *cmd,
                                          void *mconfig,
                                          const char *arg )
{
    DEBUGLOG("call: set_reqcount_addbufnum: %s", arg);
    reqcounter_config *config = (reqcounter_config *)
        ap_get_module_config(cmd->server->module_config, &reqcounter_module);
    
    config->add_buf_num = atoi(arg);
    DEBUGLOG("config->add_buf_num : %d", config->add_buf_num );
    DEBUGLOG("end : set_reqcount_add_buf_num");
    return NULL;
}

static const char *set_reqcount_persent_flag(cmd_parms *cmd, void *mconfig, int flg)
{
    DEBUGLOG("call: set_reqcount_persent_flag: %d", flg);
    
    reqcounter_config *config = (reqcounter_config *)
        ap_get_module_config(cmd->server->module_config, &reqcounter_module);
    
    config->persent_flag = flg;
    DEBUGLOG("config->persent_flag : %d", config->persent_flag);
    
    DEBUGLOG("end : set_reqcounter_persent_flag");
    return NULL;
}

/*
static const char *set_shm_lockfile(cmd_parms *cmd, void *mconfig, const char *arg)
{
    DEBUGLOG("call: set_shm_lockfile: %s", arg);
    reqcounter_config *config = (reqcounter_config *)
        ap_get_module_config(cmd->server->module_config, &reqcounter_module);
    
    config->lockfile = ap_server_root_relative(cmd->pool, arg);
    DEBUGLOG("config->lockfile : %s", config->lockfile );
    DEBUGLOG("end : set_shm_lockfile");
    return NULL;
}

static const char *set_shm_path(cmd_parms *cmd, void *mconfig, const char *arg)
{
    DEBUGLOG("call: set_shm_path: %s", arg);
    reqcounter_config *config = (reqcounter_config *)
        ap_get_module_config(cmd->server->module_config, &reqcounter_module);
    config->shmfile = ap_server_root_relative(cmd->pool, arg);
    DEBUGLOG("config->shmfile : %s", config->shmfile );
    DEBUGLOG("end : set_shm_path");
    return NULL;
}
*/

static const char *set_shm_dir(cmd_parms *cmd, void *mconfig, const char *arg)
{
    DEBUGLOG("call: set_shm_dir: %s", arg);
    reqcounter_config *config = (reqcounter_config *)
        ap_get_module_config(cmd->server->module_config, &reqcounter_module);
    config->shmdir = ap_server_root_relative(cmd->pool, arg);
    DEBUGLOG("config->shmdir : %s", config->shmdir );
    DEBUGLOG("end : set_shm_dir");
    return NULL;
}

static command_rec reqcounter_cmds[] = {
    AP_INIT_FLAG("RequestCount", set_reqcount_flag, NULL, RSRC_CONF,
                 "Enable to Request Counter.(On|Off)"),
    AP_INIT_TAKE1("RequestCountShortRangeSeconds", set_reqcount_range_short, NULL, RSRC_CONF,
                  ""),
    AP_INIT_TAKE1("RequestCountLongRangeMinutes", set_reqcount_range_long, NULL, RSRC_CONF,
                  ""),
    AP_INIT_TAKE1("RequestCountAddBufNum", set_reqcount_addbufnum, NULL, RSRC_CONF,
                  "The Number of additional buffers to ShmData ( default: 100 )"),
    AP_INIT_FLAG("RequestCountSetRandomPersent", set_reqcount_persent_flag, NULL, RSRC_CONF,
                 "Enable to Set Random Persent (0-100).(On|Off)"),
    AP_INIT_TAKE1("RequestCountShmDir", set_shm_dir, NULL, RSRC_CONF,
                  "Base Directory of shared memory and global mutex"),
    /*
    AP_INIT_TAKE1("RequestCountLockfile", set_shm_lockfile, NULL, RSRC_CONF,
                  "Filename of global mutex"),
    AP_INIT_TAKE1("RequestCountShmFile", set_shm_path, NULL, RSRC_CONF,
                  "The path of shared memory to allocate for request counts.(default:NULL)"),
    */
    {NULL}
};

static int reqcounter_post_config(apr_pool_t *pconf, apr_pool_t *plog,
                                  apr_pool_t *ptemp, server_rec *s)
{
    DEBUGLOG("call: reqcounter_post_config");
    apr_status_t rv;
    reqcounter_config *config;
    void *userdata = NULL;
    const char *userdata_key = "reqcounter_post_config";

    apr_pool_userdata_get(&userdata, userdata_key, s->process->pool);
    if( userdata == NULL ) {
        apr_pool_userdata_set((const void *)1, userdata_key,
                              apr_pool_cleanup_null, s->process->pool);
        return OK;
    }

    config = (reqcounter_config *)ap_get_module_config( s->module_config, &reqcounter_module);

    ap_add_version_component(pconf, "mod_reqcounter/$Revision $");

    int server_num = 0;
    {
        server_rec *is;
        is = s;
        do {
            server_num ++;
        } while( ( is = is->next ) != NULL );
    }

    size_t size = sizeof( server_list_t ) + sizeof( server_count_t ) * ( server_num + config->add_buf_num );

    char *shmname = apr_pstrcat( pconf, config->shmdir, "shared", NULL );
    
    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, NULL,
                 "Create or Attach shared memory. name=%s : size=%d",
                 shmname,
                 (int)size );
    
    rv = apr_shm_attach( &(config->shm), shmname, pconf );
    if( APR_SUCCESS != rv ) {
        DEBUGLOG("Creating shared memory");
        rv = apr_shm_create( &(config->shm), size, shmname, pconf );
        if( APR_SUCCESS != rv ) {
            ap_log_error(APLOG_MARK, APLOG_CRIT, 0, 0,
                         "mod_reqcount: Failed to create shared memory '%s'",
                         shmname);
            return HTTP_INTERNAL_SERVER_ERROR;
        }
    }
    config->server_list = (server_list_t *)apr_shm_baseaddr_get( config->shm );

    memset( config->server_list, 0, size);
    
    config->server_list->head = config->server_list->base;
    
    {
        server_count_t *sc = config->server_list->base;
        server_rec *is;
        is = s;
        int already_count = 0;
        while( is ) {
            char *fname = apr_psprintf( pconf, "%d.mutex", already_count);
            char *mutex_name = apr_pstrcat( pconf, config->shmdir, fname, NULL );
            strcpy( sc->server_hostname, is->server_hostname );
            strcpy( sc->mutex_name, mutex_name );
            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                         "Create global mutex '%s'",
                         mutex_name);
            rv = apr_global_mutex_create(&(sc->mutex),
                                         mutex_name,
                                         APR_LOCK_DEFAULT, pconf );
            if( rv != APR_SUCCESS ) {
                ap_log_error(APLOG_MARK, APLOG_CRIT, 0, 0,
                             "mod_reqcount: Failed to create global mutex '%s'",
                             mutex_name);
                return HTTP_INTERNAL_SERVER_ERROR;
            }
            sc->last_apr_time = 0;
            sc->is_use = 1;
            sc->next = ( sc + 1 );
            sc++;
            is = is->next;
            already_count ++;
        }
        int i;
        for( i = already_count; i < server_num + config->add_buf_num; i ++ ) {
            char *fname = apr_psprintf( pconf, "%d.mutex", i);
            char *mutex_name = apr_pstrcat( pconf, config->shmdir, fname, NULL );
//            sc->server_hostname = "                                                                      ";
            strcpy( sc->mutex_name, mutex_name );
            ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, NULL,
                         "Create global mutex '%s'",
                         mutex_name);
            rv = apr_global_mutex_create(&(sc->mutex),
                                         mutex_name,
                                         APR_LOCK_DEFAULT, pconf );
            if( rv != APR_SUCCESS ) {
                ap_log_error(APLOG_MARK, APLOG_CRIT, 0, 0,
                             "mod_reqcount: Failed to create global mutex '%s'",
                             mutex_name);
                return HTTP_INTERNAL_SERVER_ERROR;
            }
            sc->last_apr_time = 0;
            sc->is_use = 0;
            sc->next = ( sc + 1 );
            sc++;
        }
        sc--;
        sc->next = NULL;
    }
    
    /*
    rv = apr_global_mutex_create( &config->mutex, config->lockfile, APR_LOCK_DEFAULT, pconf);

    if( rv != APR_SUCCESS ) {
        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
                     "Failed to create mod_reqcounter global mutex file '%s'",
                     config->lockfile );
        return HTTP_INTERNAL_SERVER_ERROR;
    }

    if( config->mutex ) apr_global_mutex_lock( config->mutex );

    rv = apr_shm_attach(&config->shm, config->shmfile, pconf);
    if( APR_SUCCESS != rv ) {
        DEBUGLOG("Creating shared memory");
        rv = apr_shm_create(&config->shm, sizeof(apr_table_t*),
                            config->shmfile, pconf);
        if(rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
                         "Faled to create mod_reqcounter shared segment file '%s'",
                         config->shmfile ? config->shmfile : "NULL");
            return HTTP_INTERNAL_SERVER_ERROR;
        }
    }
    else {
        DEBUGLOG("Joining shared memory");
    }
    config->data = apr_shm_baseaddr_get(config->shm);
    memset( config->data, 0, sizeof(apr_table_t*));
    
    */
    
    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, s, "mod_reqcounter initialized");
    
    DEBUGLOG("end : reqcounter_post_config");
    return OK;
}

static void reqcounter_child_init(apr_pool_t *p, server_rec *s)
{
    DEBUGLOG("call: reqcounter_child_init");

    apr_status_t rv;
    reqcounter_config *config = (reqcounter_config *)ap_get_module_config( s->module_config,
                                                                           &reqcounter_module );

    if(!config->server_list) {
        DEBUGLOG("Attach to shared memory: %s", apr_pstrcat( p, config->shmdir, "shared", NULL ) );
        rv = apr_shm_attach(&(config->shm), apr_pstrcat( p, config->shmdir, "shared", NULL ), p );
        if( rv != APR_SUCCESS ) {
            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
                         "mod_reqcounter: Failed to attach to shared memory '%s'",
                         apr_pstrcat( p, config->shmdir, "shared", NULL ) );
            return;
        }
    }
    config->server_list = (server_list_t *)apr_shm_baseaddr_get( config->shm );

    {
        server_count_t *sc;
        sc = config->server_list->head;
        do {
            DEBUGLOG("Attach to global mutex : %s", sc->mutex_name );
            rv = apr_global_mutex_child_init( &(sc->mutex), sc->mutex_name, p);
            if( rv != APR_SUCCESS ) {
                ap_log_error( APLOG_MARK, APLOG_CRIT, rv, s,
                              "mod_reqcounter: Failed to attach global mutex '%s'",
                              sc->mutex_name );
                return;
            }
        } while( ( sc = (server_count_t *)sc->next) != NULL);
    }
    
    /*
    const apr_array_header_t *arr = apr_table_elts( config->server_table );
    apr_table_entry_t *elts = (apr_table_entry_t *)arr->elts;
    int i;
    for( i = 0; i < arr->nelts; i ++ )  {
        DEBUGLOG("elts[%d] : %s => %s",
                 i, elts[i].key, elts[i].val );
    }
    */
    /*
      
    rv = apr_global_mutex_child_init( &config->mutex,
                                      config->lockfile, p);
    if( rv != APR_SUCCESS ) {
        ap_log_error( APLOG_MARK, APLOG_CRIT, rv, s,
                      "Failed to attach to mod_reqcounter global mutex file '%s'",
                      config->lockfile );
        return;
    }
    if(!config->shm) {
        rv = apr_shm_attach(&config->shm, config->shmfile, p);
        if( rv != APR_SUCCESS) {
            ap_log_error(APLOG_MARK, APLOG_CRIT, rv, s,
                         "Failed to attach to mod_reqcounter shared memory file '%s'",
                         config->shmfile ? config->shmfile : 'NULL' );
            return;
        }
    }
    config->data = apr_shm_baseaddr_get(config->shm);
    */
    DEBUGLOG("end : reqcounter_child_init");
}




static unsigned int get_host_count(request_rec *r, unsigned int *short_count, unsigned int *long_count )
{
    DEBUGLOG( "call: get_host_count: %s", r->hostname );
    
    reqcounter_config *config;
    config = (reqcounter_config *)ap_get_module_config(r->server->module_config, &reqcounter_module);

    server_count_t *my_sc = config->server_list->head;
    while( my_sc->next != NULL && strcmp( my_sc->server_hostname, r->hostname ) != 0 && my_sc->is_use != 0 ) {
//        DEBUGLOG( "[inl] : my_sc->server_hostname = '%s' : mutex = '%s'",
//                  my_sc->server_hostname, my_sc->mutex_name );
        my_sc = ( server_count_t *)my_sc->next;
    }
//    DEBUGLOG( "[use] : my_sc->server_hostname = '%s' : mutex = '%s' : is_use = %d",
//              my_sc->server_hostname, my_sc->mutex_name, my_sc->is_use );

    if( my_sc->mutex ) apr_global_mutex_lock( my_sc->mutex );
    
    if( my_sc->is_use == 0 ) {
        DEBUGLOG( "Set New Host : %s", r->hostname );
        strcpy( my_sc->server_hostname, r->hostname );
        my_sc->is_use = 1;
    }

    apr_time_exp_t rt;
    apr_time_exp_gmt( &rt, r->request_time );
    
    int ci = rt.tm_min % config->range_long * 60 + rt.tm_sec;
//    DEBUGLOG( "%04d-%02d-%02d %02d:%02d:%02d [%d]",
//             rt.tm_year + 1900, rt.tm_mon + 1, rt.tm_mday, rt.tm_hour, rt.tm_min, rt.tm_sec, ci);

    DEBUGLOG("last_apr_time = %ld : req_apr_time = %ld", my_sc->last_apr_time, r->request_time );
    DEBUGLOG("last_apr_sec = %ld : req_apr_sec = %ld", apr_time_sec( my_sc->last_apr_time ), apr_time_sec( r->request_time ) );
    
    if( apr_time_sec( r->request_time ) != apr_time_sec( my_sc->last_apr_time ) ) {
//        int i;
        if( apr_time_sec( r->request_time ) - apr_time_sec( my_sc->last_apr_time ) >= config->range_long * 60 ) {
            DEBUGLOG("patern a");
            memset( my_sc->count, 0, sizeof( my_sc->count ) );
            /*
            for( i = 0; i < config->range_long * 60; i ++ ) {
                my_sc->count[i] = 0;
            }
            */
        }
        else {
            DEBUGLOG("patern b");
            apr_time_exp_t lt;
            apr_time_exp_gmt( &lt, my_sc->last_apr_time );
            int li = lt.tm_min % config->range_long * 60 + lt.tm_sec;
            if( li < ci ) {
                DEBUGLOG("patern b1 : %d - %d", li + 1, ci);
                memset( my_sc->count + li + 1, 0, sizeof( unsigned int ) * ( ci - li + 1 ) );
                /*
                for( i = li + 1; i <= ci; i ++ ) {
                    my_sc->count[ i ] = 0;
                }
                */
            }
            else if( li == ( config->range_long * 60 - 1 ) ) {
                DEBUGLOG("patern b2 : 0 - %d", ci );
                memset( my_sc->count, 0, sizeof( unsigned int ) * ci );
                /*
                for( i = 0; i <= ci; i ++ ) {
                    my_sc->count[i] = 0;
                }
                */
            }
            else {
                DEBUGLOG("patern b3 : 0 - %d & %d - %d", ci, li + 1, config->range_long * 60);
                memset( my_sc->count, 0, sizeof( unsigned int ) * ci );
                /*
                for( i = 0; i <= ci; i ++ ) {
                    my_sc->count[i] = 0;
                }
                */
                memset( my_sc->count + li + 1, 0, sizeof( unsigned int ) * ( config->range_long * 60 - li + 1 ) );
                /*
                for( i = li + 1; i < config->range_long * 60; i ++ ) {
                    my_sc->count[i] = 0;
                }
                */
            }
        }
        my_sc->last_apr_time = r->request_time;
    }
    my_sc->count[ci] ++;

    DEBUGLOG( "config->range_short = '%d' : config->range_long = '%d'", config->range_short, config->range_long );
    {
        int i;
        for( i = 0; i < config->range_long * 60; i ++ ) {
            *long_count += my_sc->count[i];
        }
        if( ci >= config->range_short - 1 ) {
            for( i = ci - config->range_short - 1; i <= ci; i ++ ) {
                *short_count += my_sc->count[i];
            }
        }
        else {
            for( i = config->range_long * 60 - config->range_short - 1 - ci; i < config->range_long * 60; i ++ ) {
                *short_count += my_sc->count[i];
            }
            for( i = 0; i <= ci; i ++ ) {
                *short_count += my_sc->count[i];
            }
        }
    }
    DEBUGLOG( "hostname = '%s' : short_count = '%d' : long_count = '%d'", my_sc->server_hostname, *short_count, *long_count );
    if( my_sc->mutex ) apr_global_mutex_unlock( my_sc->mutex );
    DEBUGLOG("end : get_host_count");
    return 0;
}

static int gen_random_num( request_rec *r)
{
    unsigned int msec = apr_time_msec( r->request_time );
    return 0 + (int)(rand_r(&msec)*(100-0+1.0)/(1.0+RAND_MAX));
}

static int reqcounter_post_read_request(request_rec *r)
{
    DEBUGLOG("call: reqcounter_post_read_request : %s %s",
             r->hostname, r->uri);
    reqcounter_config *config = (reqcounter_config *)ap_get_module_config( r->server->module_config,
                                                                           &reqcounter_module );
    if( !(config->flag) ) return DECLINED;
    if( !ap_is_initial_req(r)) return DECLINED;

    DEBUGLOG("r->headers_in, Host : %s",
             apr_table_get( r->headers_in, "Host" ) );
    unsigned int short_count = 0;
    unsigned int long_count = 0;
    get_host_count( r, &short_count, &long_count );
    apr_table_setn(r->subprocess_env, "RC_LONG", apr_psprintf( r->pool, "%d", long_count ) );
    apr_table_setn(r->subprocess_env, "RC_SHORT", apr_psprintf( r->pool, "%d", short_count ) );
    if( config->persent_flag ) {
        int rand = gen_random_num( r );
        apr_table_setn(r->subprocess_env, "RC_PERSENT", apr_psprintf( r->pool, "%d", rand ) );
        DEBUGLOG( "   rand : %d", rand );
    }
    DEBUGLOG("end : reqcounter_post_read_request");
    return DECLINED;
}

static void reqcounter_register_hooks(apr_pool_t *p)
{
    DEBUGLOG("call: reqcounter_register_hooks");

    ap_hook_post_read_request( reqcounter_post_read_request, NULL, NULL,
                               APR_HOOK_MIDDLE );
    ap_hook_post_config( reqcounter_post_config, NULL, NULL,
                         APR_HOOK_MIDDLE );
    ap_hook_child_init( reqcounter_child_init, NULL, NULL,
                        APR_HOOK_MIDDLE );
    DEBUGLOG("end : reqcounter_register_hooks");
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA reqcounter_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                            /* create per-dir    config structures */
    NULL,                            /* merge  per-dir    config structures */
    reqcounter_create_server_config, /* create per-server config structures */
    NULL,                            /* merge  per-server config structures */
    reqcounter_cmds,                 /* table of config file commands       */
    reqcounter_register_hooks        /* register hooks                      */
};

